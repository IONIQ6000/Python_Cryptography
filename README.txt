All code is built in Python 3.9.0, built in Visual Studio Code. 

The codes will run without needing any extra special parameters or plugins. 

1. Under file = Q1.py

The recovered plaintext is : THETIMEHASCOMETHEWALRUSSAIDTOTALKOFMANYTHINGSOFSHOESANDSHIPSANDSEALINGWAXOFCABBAGESANDKINGSANDWHYTHESAISBOILINGHOTANDWHETHERPIGSHAVEWINGSBUTWAITABITTHEOYSTERSCRIEDBEFOREWEHAVEOURCHATFORSOMEOFUSAREOUTOFBREATHANDALLOFUSAREFATNOHURRYSAIDTHECARPENTERTHEYTHANKEDHIMMUCHFORTHATALOAFOFBREADTHEWALRUSSAIDISWHATWECHIEFLYNEEDPEPPERANDVINEGARBESIDESAREVERYGOODINDEEDNOWIFYOUREREADYOYSTERSDEARWECANBEGINTOFEED

And the key is 

Q G Z A F O L B V S K J Y W T C M H X P D U E N I R
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

The way the Python code works is it takes the plaintext and analyzes it by counting the times a letter appears and printing the list every time I try a letter to replace in the entire plaintext to slowly reveal the encrypted message. It took a long time, but having access to the frequency of times a letter appeared and the amount of times a common letter is used in the English alphabet helps to not have to spend millions of years to decrypt the plaintext. The code will begin with the plain text analyzation and then ask what letter you want to find and what letter to replace it with and the code will not let you find the same letter twice and will print the final results for the key and plaintext. 

2. 
a. For this question, knowing how many seconds in a year can help to determine how many years it would take for a computer that can test 2^40 keys a second. So 365 days * 24 hours * 60 minutes * 60 seconds is 31536000 seconds. Then to find out what is the expected time to find the key in the given keyspace in seconds is we take the keyspace and divide it by the speed of the computer. 
2^88/2^40 which is 2^88-^40 which is 2^48 keys per second. We take that number and divide it by how many seconds in a year. 
a. 2^48/31536000 which is 8925512.96013 or 8,925,513 years. 
b. We repeat the process with part b by doing 2^112-^40 which is 2^72. Then 2^72/31536000 is 1.4974526 * 10^14 years. 
c. We repeat the process with part c by doing 2^256-^40 which is 2^216. Then 2^216/31536000 is 3.3394309 * 10^57 years. 

3.  Under file = Q3.py

The answer for question 3 is below: 

The next 32 keystream bits and the contents of X,Y,Z 
 
Keystream bits = 100000110111000001111000000110011

X = (x0,x1,...,x18) = 0001101000000000000
Y = (y0, y1,..., y21) = 1111110101010101010101
Z = (z0, z1,..., z22) = 00110101011110000101010

The code simply implements the algorithm provided by the A5/1. The code runs through the three streams as listed and performs the calculations as provided by the algorithm in the presentation.

4.  Under file = Q4.py

The answer for question 4 is below:

Public key provided in Question 4 [18, 30, 7, 26] , n = 47
m = 6
Private key generated by the code [3, 5, 9, 20]
Message in binary = 1101
Encrypted message = 74

The code will run and do the modular multiplicative inverse with the m and n values with the public key to find the private key. The code also provides the encrypted message built in the code. 


5. Trudy will not be able to use the MiM attack in this situation mainly because unless Trudy would be able to solve for discrete log to find a or b, she will not be able to see the communication between Alice and Bob. Trudy will not be able to substitute her own number in conjunction with Alice and Bobâ€™s number.
